如果没有坏点，那么就在A口输入的时候，根据pkt_type==01/10，将目的节点坐标的x或者y修正为和源节点一样，减少移动
这种分叉多播的优先级应当比单播要高，这样子三级仲裁器比较简单好做。
三级仲裁器：
输入是multicast_req, qos_req, req，multicast_vld, qos_vld.
if(multicast_vld) gnt = multicast_vld & (~(multicast_vld-1))
xxx
这样子就会得到三个gnt：multicast_gnt，qos_gnt，req_gnt
然后如果当前其实不需要broadcast（比如说这个broadcast请求实际上不需要这个端口输出，但这个只能根据仲裁的结果来判断），就采用qos_gnt（如果有qos_vld） ，没有qos就用req_gnt
基础的qos_gnt和req_gnt，都在：1. 单播、2. 多播但没有到达目标行列的时候、3. 广播但还没有到达目标行列的时候。 才会使用。

要不这样，如果有坏点，那A输入口的包只能进行单播，这样子的话就可以减少一点逻辑，并且实现起点的X、Y绕过坏点的办法。
然后正常多播、广播的时候，如果目标方向是坏点，就需要进行重映射。
坏点的rdy信号一直是高电平，这样子我们就把包传给坏点就行，少一点逻辑。

算了，坏点还是按照复制包去做吧，至少这样只用在A口做一些逻辑和代码，然后其他口就if(pg_en)判断一下，有坏点就按照单点的逻辑去做。

这样子就完备了。

现在的改动是要求实现多播广播的路由结构以及之后的寄存器保存路由结果（需要所有输入buffer支持，但这样就不用修改逻辑）、实现输入口复制包（需要在A口添加计数器以及其他东西，我可以检测当前包的tgt，然后根据它的tgt是否满了来判断是否已经OK，这一块也需要修改输入口的buffer，那我输入口的多播广播重映射这块，需要添加if pg_en， tgt=0这样子的逻辑，好让对应的坐标在一开始就是0，方便后续维护），而且这一块还要考虑和正常包释放（下游拿了所有msk就释放）的逻辑修改，要变成tgt到最大值再释放。
这样子就实现了多播广播的分叉和解耦，实现了坏点情况下的多播广播操作


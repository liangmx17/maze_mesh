先不考虑坏点
肯定是正常按照单播到达目标范围之后，开始多播是最好的，广播的话就是就地开始横向多播，然后开始纵向多播
这个范围的坐标在输入的时候，A口入口之前就考虑一下，在输入的时候判断如果是多播，就根据当前节点去重映射他的坐标
广播的话就不用动。
然后多播先正常发送，到达了目标节点之后，根据type类型去进行路由，如果是多播，那么就发送到多播模块中进行多播（复制包）
如果是广播，那么先进行横向多播，然后每个包到了目标节点之后开始纵向多播。
还是加上两bit去进行约束，让多播和广播有标识吧。
这个多播广播的模块也很麻烦啊，如果要增加一个模块的话，肯定要增加一个buffer输入，这样子的话，就肯定会要求增加nwse的仲裁器深度，这样子就很麻烦了。
如果能够和A buffer共用，那么会不会好很多呢？
如果共用的话，那么就是A buffer要有两个输入口，至少两个buffer缓存，而且还得有一个多播的寄存器mask
好处是不用增加后续的仲裁器端口，而且如果要堵塞的话，把输入的堵塞堵住会好一些，网络内总包少一点不容易堵其他地方。

缺点是要重新设计输入缓存，不能使用irs_n

思考了一下，还是不要放在A口，而是在router的部分去进行复制，这样子不用涉及包数据的移动。
缺点是这样子的话每个输入口的router都要有一个包复制的模块，光是寄存器需要8*2*5 = 80bit，放在整个64节点就是接近5120bit，快3000的面积。优点是逻辑简单
可以先实现一个，确认没有什么问题之后，再去简化一下，让一个模块同时只能泛洪多播一个/两个（x、y两个方向的，广播的话需要15个，所以必须保留这么多才行），这样子一个node就要新增8*2 = 16bit，整个64节点就是1024bit，面积可以接受。

# MAZE 节点架构设计文档

## 概述

本文档描述了MAZE网络芯片节点的内部架构设计，基于非流水线的直接路由架构，支持四方向网格连接和故障感知路由算法。

## **重要：接口配置说明**

**每个节点只例化以下三个接口**：
- **1个A接口** (`interface_a.sv`): 外部数据包输入
- **1个B接口** (`interface_b.sv`): 外部数据包输出
- **1个C接口** (`interface_c.sv`): **内部包含4个输入端口和4个输出端口，对应NWSE四个方向**

**关键点**：
- ❌ **错误做法**: 例化4个或8个独立的C接口
- ✅ **正确做法**: 例化1个C接口，其内部包含NWSE四个方向的输入和输出端口

## 节点内部架构

### 整体结构

```
                ┌─────────────────────────────────────────────────────┐
                │                    MAZE节点                        │
                ├─────────────────────────────────────────────────────┤
                │  输入端口 (5个)                                     │
                │  ├─ A口 (外部输入)    → IRS_N                       │
                │  └─ C接口(1个) → IRS_N                             │
                │     ├─ C口_N (北方输入)                            │
                │     ├─ C口_W (西方输入)                            │
                │     ├─ C口_S (南方输入)                            │
                │     └─ C口_E (东方输入)                            │
                │                                                     │
                │  路由处理层                                         │
                │  ├─ 路由单元_A  → 故障感知XY路由算法                │
                │  ├─ 路由单元_N  → 故障感知XY路由算法                │
                │  ├─ 路由单元_W  → 故障感知XY路由算法                │
                │  ├─ 路由单元_S  → 故障感知XY路由算法                │
                │  └─ 路由单元_E  → 故障感知XY路由算法                │
                │                                                     │
                │  请求生成                                           │
                │  ├─ 请求_A  → 5-bit one-hot (N,W,S,E,B)             │
                │  ├─ 请求_N  → 5-bit one-hot (N,W,S,E,B)             │
                │  ├─ 请求_W  → 5-bit one-hot (N,W,S,E,B)             │
                │  ├─ 请求_S  → 5-bit one-hot (N,W,S,E,B)             │
                │  └─ 请求_E  → 5-bit one-hot (N,W,S,E,B)             │
                │                                                     │
                │  输出仲裁 (5个仲裁器)                                │
                │  ├─ 仲裁器_N  → 4输入 QoS仲裁                       │
                │  ├─ 仲裁器_W  → 4输入 QoS仲裁                       │
                │  ├─ 仲裁器_S  → 4输入 QoS仲裁                       │
                │  ├─ 仲裁器_E  → 4输入 QoS仲裁                       │
                │  └─ 仲裁器_B  → 4输入 QoS仲裁                       │
                │                                                     │
                │  输出端口 (5个)                                     │
                │  ├─ B口 (外部输出)    ← IRS_N (RO_EN=1)             │
                │  └─ C接口(1个) ← IRS_N (RO_EN=1)                     │
                │     ├─ C口_N (北方输出)                            │
                │     ├─ C口_W (西方输出)                            │
                │     ├─ C口_S (南方输出)                            │
                │     └─ C口_E (东方输出)                            │
                └─────────────────────────────────────────────────────┘
```

## 详细组件说明

### 1. 输入端口层

#### IRS_N缓冲模块
- **功能**: 提供输入数据包的缓冲和流量控制，同时作为寄存器输入输出
- **配置**: 标准IRS_N配置，支持反压控制
- **接口**: 5个独立的IRS_N实例，每个对应一个输入端口
- **关键设计**: IRS_N内部已实现寄存器功能，**无需在node代码中额外打拍**

#### 输入端口映射
- **A口**: `interface_a.sv` - 外部网络输入
- **C接口**: `interface_c.sv` - **关键说明：每个节点只例化一个C接口，该接口内部包含4个输入端口**
  - C口_N: 北方邻居节点输入
  - C口_W: 西方邻居节点输入
  - C口_S: 南方邻居节点输入
  - C口_E: 东方邻居节点输入

### 2. 路由处理层

#### 独立路由单元 (5个)
每个输入端口对应一个独立的路由处理单元:

**输入信号**:
- 数据包有效性和数据内容 (从IRS_N输出)
- 当前节点坐标 (X_Local, Y_Local)
- 故障节点信息 (REGISTER信号)

**处理逻辑**:
1. 解析数据包的目标坐标 (X_Destination, Y_Destination)
2. 执行故障感知的XY路由算法 (详见 `路由策略.md`)
3. 生成5-bit one-hot输出请求信号

**输出信号**:
- `req_N`: 请求向北方输出
- `req_W`: 请求向西方输出
- `req_S`: 请求向南方输出
- `req_E`: 请求向东方输出
- `req_B`: 请求向本地输出 (B口)

#### 故障感知XY路由算法

**基本原理**:
- 根据目标坐标和当前坐标确定基本方向
- 考虑故障节点位置 (REGISTER信号) 进行路径调整
- 支持东方、西方、南方、北方的绕行策略

**故障相对位置类型**:
- `NORMAL`: 正常状态，无故障影响
- `N_OF_x`: 当前节点在故障节点北方
- `NE_OF_x`: 当前节点在故障节点东北方
- `E_OF_x`: 当前节点在故障节点东方
- `SE_OF_x`: 当前节点在故障节点东南方
- `S_OF_x`: 当前节点在故障节点南方
- `SW_OF_x`: 当前节点在故障节点西南方
- `W_OF_x`: 当前节点在故障节点西方
- `NW_OF_x`: 当前节点在故障节点西北方

### 3. 输出仲裁层

#### 仲裁器架构 (5个)
每个输出端口对应一个独立的4输入仲裁器:

**仲裁器输入映射**:
- **仲裁器_N**: {请求_A, 请求_W, 请求_S, 请求_E} (排除请求_N)
- **仲裁器_W**: {请求_A, 请求_N, 请求_S, 请求_E} (排除请求_W)
- **仲裁器_S**: {请求_A, 请求_N, 请求_W, 请求_E} (排除请求_S)
- **仲裁器_E**: {请求_A, 请求_N, 请求_W, 请求_S} (排除请求_E)
- **仲裁器_B**: {请求_A, 请求_N, 请求_W, 请求_S, 请求_E} (全部5个输入)

**QoS仲裁逻辑**:
- 高QoS (QoS=1) 数据包获得绝对优先权
- 同QoS级别数据包采用轮询或固定优先级
- 仲裁延迟: 1个时钟周期

### 4. 输出端口层

#### IRS_N输出缓冲模块
- **功能**: 提供输出数据包的缓冲和流量控制，同时作为寄存器输出
- **配置**: IRS_N (RO_EN=1) 寄存器输出模式
- **接口**: 5个独立的IRS_N实例，每个对应一个输出端口
- **关键设计**: IRS_N内部已实现寄存器功能，**无需在node代码中额外打拍**

#### 输出端口映射
- **B口**: `interface_b.sv` - 外部网络输出
- **C接口**: `interface_c.sv` - **关键说明：每个节点只例化一个C接口，该接口内部包含4个输出端口**
  - C口_N: 北方邻居节点输出
  - C口_W: 西方邻居节点输出
  - C口_S: 南方邻居节点输出
  - C口_E: 东方邻居节点输出

## Node架构参数配置

### 基本参数
- **节点位置参数**:
  - `HP`: 水平坐标 (0-7)，参数化配置
  - `VP`: 垂直坐标 (0-7)，参数化配置

- **数据包格式参数**:
  - `PKT_W`: 数据包总宽度 = 23位
    - `TYPE_W`: 类型位宽度 = 2位 (00=单播, 01=X多播, 10=Y多播, 11=广播)
    - `QOS_W`: QoS位宽度 = 1位 (0=低优先级, 1=高优先级)
    - `SRCID_W`: 源ID位宽度 = 6位 (支持64个节点)
    - `TGTID_W`: 目标ID位宽度 = 6位 (支持64个节点)
    - `FLIT_W`: 数据位宽度 = 8位

- **位位置常量**:
  - `QOS_POS`: QoS位位置 = 8
  - `TYPE_POS_HI`: 类型位高位置 = 22
  - `TYPE_POS_LO`: 类型位低位置 = 21
  - `SRC_POS_HI`: 源ID高位置 = 20
  - `SRC_POS_LO`: 源ID低位置 = 15
  - `TGT_POS_HI`: 目标ID高位置 = 14
  - `TGT_POS_LO`: 目标ID低位置 = 9

- **路由方向参数**:
  - `DIR_N`: 北方向 = 3'd0
  - `DIR_W`: 西方向 = 3'd1
  - `DIR_S`: 南方向 = 3'd2
  - `DIR_E`: 东方向 = 3'd3
  - `DIR_B`: 本地输出 = 3'd4

- **故障相对位置参数**:
  - `NORMAL`: 正常状态 = 4'd0
  - `N_OF_x`: 故障节点北方 = 4'd1
  - `NE_OF_x`: 故障节点东北方 = 4'd2
  - `E_OF_x`: 故障节点东方 = 4'd3
  - `SE_OF_x`: 故障节点东南方 = 4'd4
  - `S_OF_x`: 故障节点南方 = 4'd5
  - `SW_OF_x`: 故障节点西南方 = 4'd6
  - `W_OF_x`: 故障节点西方 = 4'd7
  - `NW_OF_x`: 故障节点西北方 = 4'd8

### IRS_N配置参数
- **输入IRS_N配置**:
  - `PYLD_W`: 载荷宽度 = PKT_W (23位)
  - `IRS_DEEP`: 缓冲深度 = 2
  - `TYPE_RO_EN`: 类型 = 0 (标准读写模式)

- **输出IRS_N配置**:
  - `PYLD_W`: 载荷宽度 = PKT_W (23位)
  - `IRS_DEEP`: 缓冲深度 = 1
  - `TYPE_RO_EN`: 类型 = 1 (寄存器输出模式)

### 仲裁器参数
- **仲裁器宽度**: `WIDTH = 4` (4个输入)
- **仲裁策略**: 基于QoS的固定优先级仲裁
- **优先级规则**: 高QoS绝对优先，同QoS时固定优先级

## 关键设计特性

### 1. 并行处理能力
- **5个并行路由单元**: 每个输入端口独立处理，无资源竞争
- **5个并行仲裁器**: 每个输出端口独立仲裁，提高吞吐量
- **无阻塞设计**: 输入和输出完全解耦

### 2. 故障容错能力
- **静态故障配置**: 故障信息预配置到所有节点
- **智能路由避障**: 根据故障相对位置动态选择路径
- **自动路径重构**: 故障时自动寻找最优替代路径

### 3. QoS支持
- **两级优先级**: QoS=0 (低优先级), QoS=1 (高优先级)
- **绝对优先权**: 高QoS数据包始终优先传输
- **可预测性能**: 优先级机制确保实时性能

### 4. 流量控制
- **IRS_N缓冲**: 输入输出端口的统一缓冲机制
- **反压支持**: 支持下游节点的流量反压
- **死锁避免**: 通过路由算法和仲裁机制避免死锁

## 性能参数

### 延迟特性
- **路由计算延迟**: 1个时钟周期
- **仲裁延迟**: 1个时钟周期 (组合逻辑实现)
- **总延迟**: 2个时钟周期 (无流水线，IRS_N提供寄存器功能)
- **寄存器输入输出**: 由IRS_N模块内部实现，无需额外打拍

### 吞吐量特性
- **并行输入**: 每周期最多处理5个输入数据包
- **并行输出**: 每周期最多输出5个数据包
- **峰值吞吐量**: 受限于仲裁器冲突和网络拥塞

### 资源开销
- **路由单元**: 5个 × (比较器 + 控制逻辑)
- **仲裁器**: 5个 × (QoS仲裁逻辑)
- **缓冲模块**: 10个IRS_N实例

## 实现注意事项

### 1. 时序设计
- **时钟域**: 所有组件在同一个时钟域下工作
- **关键路径**: 路由计算和仲裁逻辑的关键路径优化
- **建立时间**: 考虑IRS_N缓冲的建立时间要求

### 2. 验证策略
- **单元测试**: 每个路由单元和仲裁器的独立测试
- **集成测试**: 整个节点功能的完整测试
- **故障测试**: 各种故障场景下的路由正确性验证

### 3. 可扩展性
- **参数化设计**: 支持不同网络规模的参数调整
- **接口标准化**: 统一的接口定义便于集成
- **模块化实现**: 各功能模块独立，便于维护和升级

## 相关文档

- [`路由策略.md`](路由策略.md): 故障感知XY路由算法详细说明
- [`topo_architecture.md`](topo_architecture.md): 拓扑模块设计文档，说明节点间C接口连接和边缘节点处理
- [`interface_a.sv`](../rtl/include/interfaces/interface_a.sv): A接口定义
- [`interface_b.sv`](../rtl/include/interfaces/interface_b.sv): B接口定义
- [`interface_c.sv`](../rtl/include/interfaces/interface_c.sv): C接口定义 (**重要：一个C接口包含NWSE四个方向的输入和输出端口**)
- [`CLAUDE.md`](CLAUDE.md): 整体项目架构和设计文档
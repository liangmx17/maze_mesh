# MAZE 拓扑模块设计文档

## 概述

本文档描述了MAZE网络拓扑模块(topo)的设计和实现。topo模块负责连接64个节点，形成8×8的网格拓扑结构，通过IRS_N缓冲器实现节点间的可靠数据传输。

## 拓扑架构

### 8×8网格拓扑

```
     N(北)
      ↑
W(西) ← → E(东)
      ↓
     S(南)

8×8节点网格:
(7,0) (7,1) ... (7,7)
  ↑     ↑         ↑
  │     │         │
(6,0) (6,1) ... (6,7)  ← 北方邻居连接
  │     │         │
  ↓     ↓         ↓
(5,0) (5,1) ... (5,7)
  ...   ...       ...
(0,0) (0,1) ... (0,7)  ← 南方邻居连接

坐标说明: [y,x] 格式，y=纵坐标(0-7,南到北)，x=横坐标(0-7,西到东)
```

### 节点坐标系统

- **X坐标**: 0-7 (从西到东)
- **Y坐标**: 0-7 (从南到北)
- **节点ID**: `node_id = {y_coord, x_coord}` (6位，各3位)

## C接口连接策略

### 连接原则

**重要：每个节点只例化一个C接口，包含4个输入端口和4个输出端口**

- **北向连接**: 节点[y,x]的C口_N输出 ↔ 节点[y+1,x]的C口_N输入
- **南向连接**: 节点[y,x]的C口_S输出 ↔ 节点[y-1,x]的C口_S输入
- **西向连接**: 节点[y,x]的C口_W输出 ↔ 节点[y,x-1]的C口_W输入
- **东向连接**: 节点[y,x]的C口_E输出 ↔ 节点[y,x+1]的C口_E输入

### 连接矩阵

对于内部节点[y,x]，其中0≤y≤7且0≤x≤7：

```
节点[y,x]的连接:
北: 输出 → C口_N → IRS_N(深度=|y-(y+1)|-1=0) → C口_N输入 ← 节点[y+1,x]
南: 输出 → C口_S → IRS_N(深度=|y-(y-1)|-1=0) → C口_S输入 ← 节点[y-1,x]
西: 输出 → C口_W → IRS_N(深度=|x-(x-1)|-1=0) → C口_W输入 ← 节点[y,x-1]
东: 输出 → C口_E → IRS_N(深度=|x-(x+1)|-1=0) → C口_E输入 ← 节点[y,x+1]
```

## 边缘节点处理

### 边缘节点定义

- **北边缘**: y=7 (最上面一行)
- **南边缘**: y=0 (最下面一行)
- **西边缘**: x=0 (最左边一列)
- **东边缘**: x=7 (最右边一列)

**注意**: 坐标格式为[y,x]，所以：
- 节点[7,0]是西南角
- 节点[7,7]是东南角
- 节点[0,0]是西北角
- 节点[0,7]是东北角

### 边缘端口处理策略

#### 输入端口处理 (无邻居节点时)

对于边缘节点没有对应邻居的输入端口，采用以下处理方式：

```
情况1: 北边缘节点 (y=7) - 无北邻居
- C口_N输入数据: tie-off to 0 (所有信号置0)
- C口_N输入valid: tie-off to 0

情况2: 南边缘节点 (y=0) - 无南邻居
- C口_S输入数据: tie-off to 0
- C口_S输入valid: tie-off to 0

情况3: 西边缘节点 (x=0) - 无西邻居
- C口_W输入数据: tie-off to 0
- C口_W输入valid: tie-off to 0

情况4: 东边缘节点 (x=7) - 无东邻居
- C口_E输入数据: tie-off to 0
- C口_E输入valid: tie-off to 0
```

#### 输出端口处理 (无邻居节点时)

对于边缘节点没有对应邻居的输出端口，采用以下处理方式：

```
情况1: 北边缘节点 (y=7) - 无北邻居
- C口_N输出: 悬空 (floating)
- C口_N输出valid: 悬空

情况2: 南边缘节点 (y=0) - 无南邻居
- C口_S输出: 悬空
- C口_S输出valid: 悬空

情况3: 西边缘节点 (x=0) - 无西邻居
- C口_W输出: 悬空
- C口_W输出valid: 悬空

情况4: 东边缘节点 (x=7) - 无东邻居
- C口_E输出: 悬空
- C口_E输出valid: 悬空
```

### 边缘节点连接示例

#### 角落节点 [7,0] - 西南角
```
连接情况:
- 北向: 输出 → C口_N → IRS_N → C口_N输入 ← 节点[6,0] ✓
- 南向: C口_S输入 ← tie-off to 0, C口_S输出 → 悬空 ✗
- 西向: C口_W输入 ← tie-off to 0, C口_W输出 → 悬空 ✗
- 东向: 输出 → C口_E → IRS_N → C口_E输入 ← 节点[7,1] ✓
```

#### 边缘节点 [3,0] - 西边缘
```
连接情况:
- 北向: 输出 → C口_N → IRS_N → C口_N输入 ← 节点[4,0] ✓
- 南向: 输出 → C口_S → IRS_N → C口_S输入 ← 节点[2,0] ✓
- 西向: C口_W输入 ← tie-off to 0, C口_W输出 → 悬空 ✗
- 东向: 输出 → C口_E → IRS_N → C口_E输入 ← 节点[3,1] ✓
```

#### 边缘节点 [0,3] - 北边缘
```
连接情况:
- 北向: C口_N输入 ← tie-off to 0, C口_N输出 → 悬空 ✗
- 南向: 输出 → C口_S → IRS_N → C口_S输入 ← 节点[1,3] ✓
- 西向: 输出 → C口_W → IRS_N → C口_W输入 ← 节点[0,2] ✓
- 东向: 输出 → C口_E → IRS_N → C口_E输入 ← 节点[0,4] ✓
```

## IRS_N深度配置

### 深度计算规则

根据题目要求：**两节点间IRS深度 = 节点曼哈顿距离 - 1**

对于相邻节点，曼哈顿距离为1，因此：
- **相邻节点间IRS深度**: 1 - 1 = **0**
- **IRS_N配置**: 直接连接，无中间缓冲级

### 实际连接

```
对于任意相邻节点连接:
节点A的C口_X输出 → IRS_N(深度0) → 节点B的C口_X输入

实际实现中，IRS_N(深度0)相当于直接导线连接，但保持IRS模块的接口协议
```

## Topo模块实现

### 模块接口

```systemverilog
module topo #(
    parameter NODE_ID_W = 6,
    parameter NODE_X_W = 3,
    parameter NODE_Y_W = 3,
    parameter NODE_COUNT = 64
)(
    input  logic clk,
    input  logic rst_n,

    // 节点接口数组 (64个节点)
    // 每个节点: A接口(输入) + B接口(输出) + C接口(NWSE四向)
    interface_a.node  a_if [NODE_COUNT],
    interface_b.node  b_if [NODE_COUNT],
    interface_c.node  c_if [NODE_COUNT]
);
```

### 连接逻辑实现

#### 内部节点连接 (1≤x≤6, 1≤y≤6)

```systemverilog
// 示例：节点[y,x]与邻居的连接
always_comb begin
    // 北向连接: [y,x]输出 → [y+1,x]输入
    if (y < 7) begin
        connect_node_to_node_north(y, x, y+1, x);
    end

    // 南向连接: [y,x]输出 → [y-1,x]输入
    if (y > 0) begin
        connect_node_to_node_south(y, x, y-1, x);
    end

    // 西向连接: [y,x]输出 → [y,x-1]输入
    if (x > 0) begin
        connect_node_to_node_west(y, x, y, x-1);
    end

    // 东向连接: [y,x]输出 → [y,x+1]输入
    if (x < 7) begin
        connect_node_to_node_east(y, x, y, x+1);
    end
end
```

#### 边缘节点处理

```systemverilog
// 北边缘节点 (y=7) - 无北邻居
if (y == 7) begin
    // C口_N输入 tie-off
    c_if[node_id].c_n_in.valid  = 1'b0;
    c_if[node_id].c_n_in.data   = '0;

    // C口_N输出 悬空 (不需要处理)
end

// 南边缘节点 (y=0) - 无南邻居
if (y == 0) begin
    // C口_S输入 tie-off
    c_if[node_id].c_s_in.valid  = 1'b0;
    c_if[node_id].c_s_in.data   = '0;
end

// 类似处理西边缘(x=0)和东边缘(x=7)
// 注意：坐标格式为[y,x]
```

## 连接验证

### 连接正确性检查

1. **内部节点**: 4个方向都有有效连接
2. **边缘节点**: 只有朝内的方向有连接
3. **角落节点**: 只有2个朝内的方向有连接
4. **IRS深度**: 所有连接使用深度0的IRS_N

### 网络连通性

- **路径存在**: 任意节点间都存在路由路径
- **无死锁**: 路由算法避免循环等待
- **容错性**: 单个节点故障不影响整体连通性

## 实现注意事项

### 1. 接口一致性

- 确保所有C接口的连接方向正确
- 输入端口连接到邻居的输出端口
- 输出端口连接到邻居的输入端口

### 2. 时序考虑

- IRS_N(深度0)引入1个时钟周期的延迟
- 全网同步时钟设计
- 关键路径优化

### 3. 可测试性

- 每个连接都可通过仿真验证
- 支持独立的边缘节点测试
- 提供网络连通性检查接口

### 4. 可扩展性

- 参数化的网格尺寸设计
- 支持不同规模的网络配置
- 模块化的连接逻辑

## 相关文档

- [`../CLAUDE.md`](CLAUDE.md): 整体项目架构和设计文档
- [`node_architecture.md`](node_architecture.md): 节点内部架构设计
- [`../rtl/include/interfaces/interface_c.sv`](../rtl/include/interfaces/interface_c.sv): C接口定义
- [`../rtl/src/topo/topo.v`](../rtl/src/topo/topo.v): 拓扑模块实现
- [`../rtl/lib/irs/irs.v`](../rtl/lib/irs/irs.v): IRS模块定义